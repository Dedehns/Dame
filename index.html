<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jeu de Dames Niveaux</title>
    <style>
        /* --- CSS pour le design et l'interface --- */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* √âcrans de Jeu/D√©marrage */
        #start-screen {
            text-align: center;
            padding: 20px;
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            width: 90%;
            margin-top: 5vh;
        }

        #game-screen {
            display: none; /* Cach√© au d√©but */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #game-status {
            margin: 15px 0;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        /* Boutons */
        .mode-button, .level-button, #reset-btn, #back-to-menu-btn {
            padding: 10px 15px;
            margin: 5px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .mode-button {
            background-color: #007bff;
            color: white;
            width: 90%;
        }
        .mode-button.disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .level-button {
            background-color: #6c757d;
            color: white;
        }
        .level-button.selected {
            background-color: #28a745;
        }
        .level-button:disabled {
            background-color: #f8d7da;
            color: #721c24;
            cursor: not-allowed;
        }
        
        #reset-btn, #back-to-menu-btn {
            background-color: #dc3545;
            color: white;
        }

        /* Plateau et Pi√®ces */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vmin; /* Utiliser vmin pour un meilleur ajustement */
            height: 90vmin;
            max-width: 400px;
            max-height: 400px;
            border: 4px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dark {
            background-color: #7b5b48; 
        }

        .light {
            background-color: #f0d2b2; 
        }

        .selected {
            box-shadow: inset 0 0 0 4px yellow; 
        }

        .possible-move {
            box-shadow: inset 0 0 0 4px limegreen; 
            cursor: pointer;
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 1px solid #000;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            position: relative;
        }
        
        .p1 {
            background-color: #000000; /* Noir (Joueur) */
        }

        .p2 {
            background-color: #ffffff; /* Blanc (IA/Adversaire) */
        }

        .king::after {
            content: 'üëë';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            color: gold;
            text-shadow: 0 0 3px #000;
        }
    </style>
</head>
<body>

    <div class="game-container">
        
        <div id="start-screen">
            <h1>Jeu de Dames üëë</h1>
            <div id="mode-selection">
                <button class="mode-button" onclick="selectMode('ia')">Jouer contre l'IA</button>
                <button class="mode-button" onclick="selectMode('local')">Joueur vs Joueur (Local)</button>
                <button class="mode-button disabled" disabled>Jouer en Ligne (N√©cessite Serveur Externe)</button>
            </div>

            <div id="ia-level-selection" style="display:none; margin-top: 20px;">
                <h2>Progression Actuelle</h2>
                <p>Niveau : <span id="current-level-display">Facile</span></p>
                <p>Victoires : <span id="victory-counter">0</span> / 5</p>
                
                <div id="level-buttons-container">
                    </div>
                
                <button class="mode-button" onclick="startGame()" style="margin-top: 15px;">D√©marrer la partie</button>
            </div>
        </div>

        <div id="game-screen">
            <h1 id="game-title">Partie en Cours</h1>
            <div id="progression-info" style="margin-bottom: 10px;">
                Mode: <span id="mode-display"></span> | Niveau: <span id="level-display"></span>
            </div>
            <div id="game-status">Au tour du Joueur Noir (P1)</div>
            <div class="board" id="board">
                </div>
            <div style="margin-top: 15px;">
                <button id="reset-btn">Recommencer</button>
                <button id="back-to-menu-btn">Menu Principal</button>
            </div>
        </div>
        
    </div>

    <script>
        // --- VARIABLES GLOBALES ET CONSTANTES ---
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('game-status');
        const resetButton = document.getElementById('reset-btn');
        const backToMenuButton = document.getElementById('back-to-menu-btn');
        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        const iaLevelSelection = document.getElementById('ia-level-selection');
        const levelButtonsContainer = document.getElementById('level-buttons-container');
        const levelDisplay = document.getElementById('level-display');
        const modeDisplay = document.getElementById('mode-display');
        const currentLevelDisplay = document.getElementById('current-level-display');
        const victoryCounterDisplay = document.getElementById('victory-counter');

        let board = [];
        let currentPlayer = 1; // 1 pour Noir (Joueur), 2 pour Blanc (Adversaire/IA)
        let selectedPiece = null;
        let gameActive = false;

        // Variables pour les niveaux et la progression
        let gameMode = 'local';
        // Note: L'IA actuelle est niveau FACILE. Les autres niveaux n√©cessitent Minimax.
        const LEVELS = ['Facile', 'Normal', 'Difficile', 'Extr√™me', 'Assistant Ma√Ætre', 'Ma√Ætre', 'Divinit√©'];
        let currentLevelIndex = 0; // Niveau actuel d√©bloqu√©
        let selectedLevelIndex = 0; // Niveau s√©lectionn√© pour la partie
        let victories = 0; // Victoires du joueur au niveau actuel (non persistant)

        // --- FONCTIONS DE GESTION DE L'INTERFACE ET DES NIVEAUX ---

        function generateLevelButtons() {
            levelButtonsContainer.innerHTML = '';
            
            LEVELS.forEach((level, index) => {
                const button = document.createElement('button');
                button.className = 'level-button';
                button.textContent = level;
                button.dataset.levelIndex = index;
                
                // G√©rer le verrouillage et la s√©lection
                if (index > currentLevelIndex) {
                    button.disabled = true;
                    button.textContent += " (Bloqu√©)";
                } else {
                    button.addEventListener('click', () => {
                        selectedLevelIndex = index;
                        // Mettre √† jour la s√©lection visuelle
                        levelButtonsContainer.querySelectorAll('.level-button').forEach(btn => {
                            btn.classList.remove('selected');
                        });
                        button.classList.add('selected');
                        
                        // R√©afficher la progression pour le niveau s√©lectionn√© si c'est le niveau actif
                        if (index === currentLevelIndex) {
                            updateProgressionDisplay();
                        } else {
                            // Si on s√©lectionne un niveau inf√©rieur (pour rejouer)
                            currentLevelDisplay.textContent = level;
                            victoryCounterDisplay.textContent = `N/A`;
                        }
                    });
                }
                
                if (index === selectedLevelIndex) {
                    button.classList.add('selected');
                }
                
                levelButtonsContainer.appendChild(button);
            });
        }

        function selectMode(mode) {
            gameMode = mode;
            
            if (mode === 'ia') {
                document.getElementById('mode-selection').style.display = 'none';
                iaLevelSelection.style.display = 'block';
                updateProgressionDisplay();
            } else {
                startGame();
            }
        }

        function updateProgressionDisplay() {
            currentLevelDisplay.textContent = LEVELS[currentLevelIndex];
            victoryCounterDisplay.textContent = `${victories} / 5`;
            generateLevelButtons();
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameScreen.style.display = 'flex';
            
            levelDisplay.textContent = LEVELS[selectedLevelIndex];
            modeDisplay.textContent = gameMode === 'ia' ? 'Joueur vs IA' : 'Joueur vs Joueur (Local)';
            
            resetGame();
        }

        function backToMenu() {
            gameScreen.style.display = 'none';
            startScreen.style.display = 'block';
            document.getElementById('mode-selection').style.display = 'block';
            iaLevelSelection.style.display = 'none';
            selectedPiece = null;
            gameActive = false;
            updateProgressionDisplay();
        }

        // --- LOGIQUE DE L'IA (NIVEAU BASIQUE/FACILE) ---
        
        function AITurn() {
            if (currentPlayer !== 2 || gameMode !== 'ia' || !gameActive) return;

            // Logique de l'IA (Tr√®s basique - Niveau Facile)
            const allMoves = getAllPossibleMoves(2);
            
            if (allMoves.length === 0) {
                checkWinCondition();
                return; 
            }

            let move = null;
            
            // Priorit√© 1 : Mouvement de capture
            move = allMoves.find(m => m.capture);

            // Priorit√© 2 : Mouvement simple al√©atoire
            if (!move) {
                const simpleMoves = allMoves.filter(m => !m.capture);
                if (simpleMoves.length > 0) {
                    move = simpleMoves[Math.floor(Math.random() * simpleMoves.length)];
                } else {
                    // Si seules des captures √©taient possibles, mais l'IA ne les a pas trouv√©es (ne devrait pas arriver avec ce code)
                    move = allMoves[0]; 
                }
            }
            
            if (move) {
                selectedPiece = { r: move.fromR, c: move.fromC }; 
                makeMove(move.r, move.c);
            }
        }

        function getAllPossibleMoves(player) {
            const allMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player) {
                        const moves = getPossibleMoves(r, c);
                        moves.forEach(m => allMoves.push({ 
                            fromR: r, fromC: c, 
                            r: m.r, c: m.c, 
                            capture: m.capture 
                        }));
                    }
                }
            }
            return allMoves;
        }


        // --- LOGIQUE DU JEU DE DAMES (C≈ìur) ---

        function initializeBoard() {
            board = Array(8).fill(null).map(() => Array(8).fill(0));

            // Pi√®ces du Joueur 1 (Noir, en haut)
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 !== 0) {
                        board[r][c] = { player: 1, isKing: false };
                    }
                }
            }

            // Pi√®ces du Joueur 2 (Blanc, en bas)
            for (let r = 5; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 !== 0) {
                        board[r][c] = { player: 2, isKing: false };
                    }
                }
            }
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            const possibleMoves = selectedPiece ? getPossibleMoves(selectedPiece.r, selectedPiece.c) : [];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.dataset.row = r;
                    square.dataset.col = c;
                    
                    if ((r + c) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }

                    const piece = board[r][c];

                    // Ajout de la pi√®ce
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', `p${piece.player}`);
                        if (piece.isKing) {
                            pieceElement.classList.add('king');
                        }
                        square.appendChild(pieceElement);
                        
                        // Ajouter le listener de s√©lection (seulement si le jeu est actif et c'est le tour du joueur humain)
                        if (piece.player === currentPlayer && gameActive && currentPlayer === 1) {
                            pieceElement.addEventListener('click', () => selectPiece(r, c));
                        }
                    }

                    // Marquer les mouvements possibles
                    const isPossible = possibleMoves.some(move => move.r === r && move.c === c);
                    if (isPossible) {
                        square.classList.add('possible-move');
                        square.addEventListener('click', () => makeMove(r, c));
                    }
                    
                    // Marquer la pi√®ce s√©lectionn√©e
                    if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) {
                        square.classList.add('selected');
                    }

                    boardElement.appendChild(square);
                }
            }
            updateStatus();
        }

        function selectPiece(r, c) {
            if (!gameActive || currentPlayer !== 1) return; // Seul le joueur 1 peut s√©lectionner

            if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) {
                selectedPiece = null;
            } else {
                selectedPiece = { r, c };
            }
            renderBoard();
        }

        function getPossibleMoves(r, c) {
            const moves = [];
            const piece = board[r][c];
            if (!piece) return moves;

            const direction = (piece.player === 1) ? 1 : -1; // P1 monte (r+1), P2 descend (r-1)
            const directions = piece.isKing ? [-1, 1] : [direction];

            for (const dir of directions) {
                // Mouvements simples et Prises
                for (const dc of [-1, 1]) {
                    const nr = r + dir;
                    const nc = c + dc;
                    
                    // Mouvement simple
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !board[nr][nc]) {
                        moves.push({ r: nr, c: nc, capture: null });
                    }
                    
                    // Mouvement de prise
                    const nnr = r + dir * 2;
                    const nnc = c + dc * 2;
                    
                    if (
                        nnr >= 0 && nnr < 8 && nnc >= 0 && nnc < 8 && 
                        board[nr][nc] && board[nr][nc].player !== currentPlayer && 
                        !board[nnr][nnc]
                    ) {
                        moves.push({ r: nnr, c: nnc, capture: { r: nr, c: nc } });
                    }
                }
            }

            return moves;
        }
        
        function makeMove(toR, toC) {
            if (!selectedPiece) return;

            const fromR = selectedPiece.r;
            const fromC = selectedPiece.c;
            const piece = board[fromR][fromC];
            
            const possibleMoves = getPossibleMoves(fromR, fromC);
            const move = possibleMoves.find(m => m.r === toR && m.c === toC);
            
            if (move) {
                // D√©placer et capturer
                board[toR][toC] = piece;
                board[fromR][fromC] = 0;
                
                if (move.capture) {
                    board[move.capture.r][move.capture.c] = 0;
                }
                
                // Promotion en Dame
                if (!piece.isKing) {
                    if (piece.player === 1 && toR === 7) {
                        board[toR][toC].isKing = true;
                    } else if (piece.player === 2 && toR === 0) {
                        board[toR][toC].isKing = true;
                    }
                }

                // Changer de joueur
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                selectedPiece = null;
                renderBoard();
                
                // V√©rifier la victoire et lancer l'IA
                if (!checkWinCondition()) {
                    if (currentPlayer === 2 && gameMode === 'ia') {
                        setTimeout(AITurn, 500); // D√©lai pour l'IA
                    }
                }
            }
        }
        
        function updateStatus() {
            const playerColor = currentPlayer === 1 ? "Noir (P1)" : "Blanc (P2)";
            statusElement.textContent = gameActive ? `Au tour du Joueur ${playerColor}` : 'Partie termin√©e.';
        }
        
        function checkWinCondition() {
            const p1Pieces = board.flat().filter(p => p && p.player === 1).length;
            const p2Pieces = board.flat().filter(p => p && p.player === 2).length;

            let winner = null;

            if (p1Pieces === 0) {
                winner = 2; // IA/Adversaire gagne
            } else if (p2Pieces === 0) {
                winner = 1; // Joueur gagne
            }
            
            if (winner) {
                gameActive = false;
                statusElement.textContent = `FIN DU JEU : Le Joueur ${winner === 1 ? 'Noir (P1)' : 'Blanc (P2)'} a gagn√© !`;
                
                // Logique de progression (mode IA uniquement)
                if (gameMode === 'ia' && selectedLevelIndex === currentLevelIndex) {
                    if (winner === 1) {
                        victories++;
                        
                        if (victories >= 5) {
                            currentLevelIndex++;
                            victories = 0; 
                            if (currentLevelIndex >= LEVELS.length) {
                                currentLevelIndex = LEVELS.length - 1; 
                                alert("F√âLICITATIONS ! Vous avez atteint le niveau Divinit√© !");
                            } else {
                                alert(`Passage au niveau sup√©rieur : ${LEVELS[currentLevelIndex]} !`);
                            }
                        }
                        updateProgressionDisplay(); // Rafra√Æchir le compteur dans l'√©cran de menu
                    }
                }
                return true; // Le jeu est termin√©
            }
            return false; // Le jeu continue
        }

        function resetGame() {
            initializeBoard();
            currentPlayer = 1;
            selectedPiece = null;
            gameActive = true;
            renderBoard();
        }

        // --- Lancement et √âv√©nements ---
        resetButton.addEventListener('click', resetGame);
        backToMenuButton.addEventListener('click', backToMenu);

        // Initialisation de l'affichage
        updateProgressionDisplay(); 
    </script>
</body>
</html>