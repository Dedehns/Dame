<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jeu de Dames Niveaux</title>
    <style>
        /* --- CSS pour le design et l'interface --- */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Ã‰crans de Jeu/DÃ©marrage */
        #start-screen {
            text-align: center;
            padding: 20px;
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            width: 90%;
            margin-top: 5vh;
        }

        #game-screen {
            display: none; /* CachÃ© au dÃ©but */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #game-status {
            margin: 15px 0;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        /* Boutons */
        .mode-button, .level-button, #reset-btn, #back-to-menu-btn {
            padding: 10px 15px;
            margin: 5px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .mode-button {
            background-color: #007bff;
            color: white;
            width: 90%;
        }
        .mode-button.disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .level-button {
            background-color: #6c757d;
            color: white;
        }
        .level-button.selected {
            background-color: #28a745;
        }
        .level-button:disabled {
            background-color: #f8d7da;
            color: #721c24;
            cursor: not-allowed;
        }
        
        #reset-btn, #back-to-menu-btn {
            background-color: #dc3545;
            color: white;
        }

        /* Plateau et PiÃ¨ces */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vmin; /* Utiliser vmin pour un meilleur ajustement */
            height: 90vmin;
            max-width: 400px;
            max-height: 400px;
            border: 4px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dark {
            background-color: #7b5b48; 
        }

        .light {
            background-color: #f0d2b2; 
        }

        .selected {
            box-shadow: inset 0 0 0 4px yellow; 
        }

        .possible-move {
            box-shadow: inset 0 0 0 4px limegreen; 
            cursor: pointer;
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 1px solid #000;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            position: relative;
        }
        
        .p1 {
            background-color: #000000; /* Noir (Joueur) */
        }

        .p2 {
            background-color: #ffffff; /* Blanc (IA/Adversaire) */
        }

        .king::after {
            content: 'ðŸ‘‘';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            color: gold;
            text-shadow: 0 0 3px #000;
        }
    </style>
</head>
<body>

    <div class="game-container">
        
        <div id="start-screen">
            <h1>Jeu de Dames ðŸ‘‘</h1>
            <div id="mode-selection">
                <button class="mode-button" onclick="selectMode('ia')">Jouer contre l'IA</button>
                <button class="mode-button" onclick="selectMode('local')">Joueur vs Joueur (Local)</button>
                <button class="mode-button disabled" disabled>Jouer en Ligne (NÃ©cessite Serveur Externe)</button>
            </div>

            <div id="ia-level-selection" style="display:none; margin-top: 20px;">
                <h2>Progression Actuelle</h2>
                <p>Niveau : <span id="current-level-display">Facile</span></p>
                <p>Victoires : <span id="victory-counter">0</span> / 5</p>
                
                <div id="level-buttons-container">
                    </div>
                
                <button class="mode-button" onclick="startGame()" style="margin-top: 15px;">DÃ©marrer la partie</button>
            </div>
        </div>

        <div id="game-screen">
            <h1 id="game-title">Partie en Cours</h1>
            <div id="progression-info" style="margin-bottom: 10px;">
                Mode: <span id="mode-display"></span> | Niveau: <span id="level-display"></span>
            </div>
            <div id="game-status">Au tour du Joueur Noir (P1)</div>
            <div class="board" id="board">
                </div>
            <div style="margin-top: 15px;">
                <button id="reset-btn">Recommencer</button>
                <button id="back-to-menu-btn">Menu Principal</button>
            </div>
        </div>
        
    </div>

    <script>
        // --- VARIABLES GLOBALES ET CONSTANTES (mÃªmes qu'avant) ---
const boardElement = document.getElementById('board');
const statusElement = document.getElementById('game-status');
const resetButton = document.getElementById('reset-btn');
const backToMenuButton = document.getElementById('back-to-menu-btn');
const startScreen = document.getElementById('start-screen');
const gameScreen = document.getElementById('game-screen');
const iaLevelSelection = document.getElementById('ia-level-selection');
const levelButtonsContainer = document.getElementById('level-buttons-container');
const levelDisplay = document.getElementById('level-display');
const modeDisplay = document.getElementById('mode-display');
const currentLevelDisplay = document.getElementById('current-level-display');
const victoryCounterDisplay = document.getElementById('victory-counter');

let board = [];
let currentPlayer = 1; 
let selectedPiece = null;
let gameActive = false;

// Variables pour les niveaux et la progression
let gameMode = 'local';
const LEVELS = ['Facile', 'Normal', 'Difficile', 'ExtrÃªme', 'Assistant MaÃ®tre', 'MaÃ®tre', 'DivinitÃ©'];
let currentLevelIndex = 0; 
let selectedLevelIndex = 0;
let victories = 0; 

// ----------------------------------------------------------------
// --- NOUVELLES FONCTIONS DE SAUVEGARDE ET CHARGEMENT (LOCALSTORAGE) ---
// ----------------------------------------------------------------

function saveProgress() {
    try {
        // Sauvegarder la progression dans le localStorage
        localStorage.setItem('dames_level', currentLevelIndex);
        localStorage.setItem('dames_victories', victories);
        console.log("Progression sauvegardÃ©e !");
    } catch (e) {
        console.error("Erreur lors de la sauvegarde de la progression:", e);
    }
}

function loadProgress() {
    try {
        // Charger la progression depuis le localStorage
        const savedLevel = localStorage.getItem('dames_level');
        const savedVictories = localStorage.getItem('dames_victories');

        if (savedLevel !== null) {
            currentLevelIndex = parseInt(savedLevel, 10);
            selectedLevelIndex = currentLevelIndex; // SÃ©lectionne le niveau le plus Ã©levÃ© dÃ©bloquÃ©
        }
        if (savedVictories !== null) {
            victories = parseInt(savedVictories, 10);
        }
        
        console.log(`Progression chargÃ©e: Niveau ${LEVELS[currentLevelIndex]}, Victoires ${victories}`);
    } catch (e) {
        console.error("Erreur lors du chargement de la progression:", e);
    }
}


// --- FONCTIONS DE GESTION DE L'INTERFACE ET DES NIVEAUX ---

function generateLevelButtons() {
    levelButtonsContainer.innerHTML = '';
    
    LEVELS.forEach((level, index) => {
        const button = document.createElement('button');
        button.className = 'level-button';
        button.textContent = level;
        button.dataset.levelIndex = index;
        
        if (index > currentLevelIndex) {
            button.disabled = true;
            button.textContent += " (BloquÃ©)";
        } else {
            button.addEventListener('click', () => {
                selectedLevelIndex = index;
                // Mettre Ã  jour la sÃ©lection visuelle
                levelButtonsContainer.querySelectorAll('.level-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                button.classList.add('selected');
                
                // RÃ©afficher la progression pour le niveau sÃ©lectionnÃ© si c'est le niveau actif
                if (index === currentLevelIndex) {
                    updateProgressionDisplay();
                } else {
                    currentLevelDisplay.textContent = level;
                    victoryCounterDisplay.textContent = `N/A`; // Pas de suivi de victoire pour les niveaux infÃ©rieurs
                }
            });
        }
        
        if (index === selectedLevelIndex) {
            button.classList.add('selected');
        }
        
        levelButtonsContainer.appendChild(button);
    });
}

function selectMode(mode) {
    gameMode = mode;
    
    if (mode === 'ia') {
        document.getElementById('mode-selection').style.display = 'none';
        iaLevelSelection.style.display = 'block';
        updateProgressionDisplay();
    } else {
        startGame();
    }
}

function updateProgressionDisplay() {
    currentLevelDisplay.textContent = LEVELS[currentLevelIndex];
    victoryCounterDisplay.textContent = `${victories} / 5`;
    generateLevelButtons();
}

function startGame() {
    startScreen.style.display = 'none';
    gameScreen.style.display = 'flex';
    
    levelDisplay.textContent = LEVELS[selectedLevelIndex];
    modeDisplay.textContent = gameMode === 'ia' ? 'Joueur vs IA' : 'Joueur vs Joueur (Local)';
    
    resetGame();
}

function backToMenu() {
    gameScreen.style.display = 'none';
    startScreen.style.display = 'block';
    document.getElementById('mode-selection').style.display = 'block';
    iaLevelSelection.style.display = 'none';
    selectedPiece = null;
    gameActive = false;
    updateProgressionDisplay();
}


// --- LOGIQUE DE L'IA (NIVEAU BASIQUE/FACILE) ---
// (Le code AITurn, getAllPossibleMoves reste inchangÃ©)
function AITurn() {
    if (currentPlayer !== 2 || gameMode !== 'ia' || !gameActive) return;
    const allMoves = getAllPossibleMoves(2); 
    
    if (allMoves.length === 0) {
        checkWinCondition();
        return; 
    }

    let move = null;
    move = allMoves.find(m => m.capture);

    if (!move) {
        const simpleMoves = allMoves.filter(m => !m.capture);
        if (simpleMoves.length > 0) {
            move = simpleMoves[Math.floor(Math.random() * simpleMoves.length)];
        } else {
            move = allMoves[0]; 
        }
    }
    
    if (move) {
        selectedPiece = { r: move.fromR, c: move.fromC }; 
        makeMove(move.r, move.c);
    }
}

function getAllPossibleMoves(player) {
    const allMoves = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (piece && piece.player === player) {
                const moves = getPossibleMoves(r, c);
                moves.forEach(m => allMoves.push({ 
                    fromR: r, fromC: c, 
                    r: m.r, c: m.c, 
                    capture: m.capture 
                }));
            }
        }
    }
    return allMoves;
}


// --- LOGIQUE DU JEU DE DAMES (CÅ“ur) ---
// (Les fonctions initializeBoard, renderBoard, selectPiece, getPossibleMoves, makeMove sont inchangÃ©es, 
// sauf pour la fonction makeMove qui appelle checkWinCondition)
function initializeBoard() {
    board = Array(8).fill(null).map(() => Array(8).fill(0));
    for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 8; c++) {
            if ((r + c) % 2 !== 0) {
                board[r][c] = { player: 1, isKing: false };
            }
        }
    }
    for (let r = 5; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if ((r + c) % 2 !== 0) {
                board[r][c] = { player: 2, isKing: false };
            }
        }
    }
}

function renderBoard() {
    boardElement.innerHTML = '';
    const possibleMoves = selectedPiece ? getPossibleMoves(selectedPiece.r, selectedPiece.c) : [];

    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const square = document.createElement('div');
            square.classList.add('square');
            square.dataset.row = r;
            square.dataset.col = c;
            
            if ((r + c) % 2 === 0) {
                square.classList.add('light');
            } else {
                square.classList.add('dark');
            }

            const piece = board[r][c];

            if (piece) {
                const pieceElement = document.createElement('div');
                pieceElement.classList.add('piece', `p${piece.player}`);
                if (piece.isKing) {
                    pieceElement.classList.add('king');
                }
                square.appendChild(pieceElement);
                
                if (piece.player === currentPlayer && gameActive && currentPlayer === 1) {
                    pieceElement.addEventListener('click', () => selectPiece(r, c));
                }
            }

            const isPossible = possibleMoves.some(move => move.r === r && move.c === c);
            if (isPossible) {
                square.classList.add('possible-move');
                square.addEventListener('click', () => makeMove(r, c));
            }
            
            if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) {
                square.classList.add('selected');
            }

            boardElement.appendChild(square);
        }
    }
    updateStatus();
}

function selectPiece(r, c) {
    if (!gameActive || currentPlayer !== 1) return;
    if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) {
        selectedPiece = null;
    } else {
        selectedPiece = { r, c };
    }
    renderBoard();
}

function getPossibleMoves(r, c) {
    const moves = [];
    const piece = board[r][c];
    if (!piece) return moves;

    const direction = (piece.player === 1) ? 1 : -1;
    const directions = piece.isKing ? [-1, 1] : [direction];

    for (const dir of directions) {
        for (const dc of [-1, 1]) {
            const nr = r + dir;
            const nc = c + dc;
            
            // Mouvement simple
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !board[nr][nc]) {
                moves.push({ r: nr, c: nc, capture: null });
            }
            
            // Mouvement de prise
            const nnr = r + dir * 2;
            const nnc = c + dc * 2;
            
            if (
                nnr >= 0 && nnr < 8 && nnc >= 0 && nnc < 8 && 
                board[nr][nc] && board[nr][nc].player !== currentPlayer && 
                !board[nnr][nnc]
            ) {
                moves.push({ r: nnr, c: nnc, capture: { r: nr, c: nc } });
            }
        }
    }
    return moves;
}

function makeMove(toR, toC) {
    if (!selectedPiece) return;

    const fromR = selectedPiece.r;
    const fromC = selectedPiece.c;
    const piece = board[fromR][fromC];
    
    const possibleMoves = getPossibleMoves(fromR, fromC);
    const move = possibleMoves.find(m => m.r === toR && m.c === toC);
    
    if (move) {
        board[toR][toC] = piece;
        board[fromR][fromC] = 0;
        
        if (move.capture) {
            board[move.capture.r][move.capture.c] = 0;
        }
        
        if (!piece.isKing) {
            if (piece.player === 1 && toR === 7) {
                board[toR][toC].isKing = true;
            } else if (piece.player === 2 && toR === 0) {
                board[toR][toC].isKing = true;
            }
        }

        currentPlayer = currentPlayer === 1 ? 2 : 1;
        selectedPiece = null;
        renderBoard();
        
        // VÃ©rifier la victoire et lancer l'IA
        if (!checkWinCondition()) {
            if (currentPlayer === 2 && gameMode === 'ia') {
                setTimeout(AITurn, 500); 
            }
        }
    }
}
        
function updateStatus() {
    const playerColor = currentPlayer === 1 ? "Noir (P1)" : "Blanc (P2)";
    statusElement.textContent = gameActive ? `Au tour du Joueur ${playerColor}` : 'Partie terminÃ©e.';
}
        
function checkWinCondition() {
    const p1Pieces = board.flat().filter(p => p && p.player === 1).length;
    const p2Pieces = board.flat().filter(p => p && p.player === 2).length;

    let winner = null;

    if (p1Pieces === 0) {
        winner = 2; // IA/Adversaire gagne
    } else if (p2Pieces === 0) {
        winner = 1; // Joueur gagne
    }
    
    if (winner) {
        gameActive = false;
        statusElement.textContent = `FIN DU JEU : Le Joueur ${winner === 1 ? 'Noir (P1)' : 'Blanc (P2)'} a gagnÃ© !`;
        
        if (gameMode === 'ia' && selectedLevelIndex === currentLevelIndex) {
            if (winner === 1) {
                victories++;
                // ðŸ›‘ SAUVEGARDE DE LA PROGRESSION ICI
                saveProgress(); 
                
                if (victories >= 5) {
                    currentLevelIndex++;
                    victories = 0;
                    // ðŸ›‘ SAUVEGARDE DU NOUVEAU NIVEAU ICI
                    saveProgress();
                    
                    if (currentLevelIndex >= LEVELS.length) {
                        currentLevelIndex = LEVELS.length - 1; 
                        alert("FÃ‰LICITATIONS ! Vous avez atteint le niveau DivinitÃ© !");
                    } else {
                        alert(`Passage au niveau supÃ©rieur : ${LEVELS[currentLevelIndex]} !`);
                    }
                }
                updateProgressionDisplay(); 
            }
        }
        return true; 
    }
    return false;
}

function resetGame() {
    initializeBoard();
    currentPlayer = 1;
    selectedPiece = null;
    gameActive = true;
    renderBoard();
}

// --- Lancement et Ã‰vÃ©nements ---
resetButton.addEventListener('click', resetGame);
backToMenuButton.addEventListener('click', backToMenu);

// ðŸ›‘ CHARGEMENT DE LA PROGRESSION AU DÃ‰MARRAGE
loadProgress();
updateProgressionDisplay();
    </script>
</body>

</html>
